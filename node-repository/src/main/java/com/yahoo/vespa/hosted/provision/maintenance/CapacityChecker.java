package com.yahoo.vespa.hosted.provision.maintenance;

import com.yahoo.config.provision.NodeResources;
import com.yahoo.config.provision.NodeType;
import com.yahoo.vespa.hosted.provision.Node;
import com.yahoo.vespa.hosted.provision.NodeRepository;
import com.yahoo.vespa.hosted.provision.node.Allocation;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.function.Function;
import java.util.stream.Collectors;

public class CapacityChecker {
    private List<Node> hosts;
    private Map<String, Node> nodeMap;
    Map<Node, List<Node>> nodeChildren;
    private Map<Node, AllocationResources> availableResources;

    public AllocationHistory allocationHistory = null;

    // TODO:: v Move this to the closed-source HV tool (until line 462)
    /**
     * A class used to store a not-yet-created node, as well as the existing nodes that can get shuffled around by
     * searching for ways to fit nodes into the repository.
     */
    static class NewNode {
        NodeResources resources;
        Allocation allocation; // TODO:: Something about this possibly not always being set in real data.
        String hostname = null;

        NewNode(NodeResources resources, Allocation allocation, String hostname) {
            this.resources = resources;
            this.allocation = allocation;
            this.hostname = hostname;
        }
        NewNode(NodeResources resources, Allocation allocation) {
            this.resources = resources;
            this.allocation = allocation;
        }
        static public NewNode from(Node node) {
            return new NewNode(node.flavor().resources(), node.allocation().orElseThrow(), node.hostname());
        }
    }

    /**
     * A class used to store information on how flexible a node is, that is, how many hosts it can potentially fit.
     */
    static class Flexiblity {
        NewNode node;
        Set<Host> possibleHosts;

        private Flexiblity(NewNode node) {
            this.node = node;
        }
        Flexiblity (NewNode node, Set<Host> allHosts) {
            this.node = node;
            this.setPossibleHosts(allHosts);
        }
        private void setPossibleHosts(Set<Host> possibleHosts) {
            this.possibleHosts = possibleHosts.stream()
                    .filter(h -> h.satisfies(node))
                    .collect(Collectors.toSet());
        }
        Flexiblity withPossibleHosts(Set<Host> possibleHosts) {
            Flexiblity f = new Flexiblity(node);
            f.setPossibleHosts(possibleHosts);
            return f;
        }
    }

    /**
     * Class used for storing the data associated with a physical host.
     */
    static class Host {
        String hostname;
        NodeResources initialResources;
        NodeResources resources;
        Set<NewNode> allocated;
        Set<NewNode> satisfiedNodes;

        Host (String hostname, NodeResources resources, Set<NewNode> allocated, Set<NewNode> possibleNodes) {
            this.hostname = hostname;
            this.initialResources = resources;
            this.resources = allocated.stream().map(a -> a.resources).reduce(resources, NodeResources::subtract);
            this.allocated = allocated;
            this.satisfiedNodes = satisfiedNodes(possibleNodes);
        }

        public String getName() { return this.hostname; }

        Host withoutNode(NewNode node, Set<NewNode> possibleNodes) {
            if (!allocated.contains(node))
                throw new IllegalArgumentException("The host does not contain the attempted removed node.");
            Set<NewNode> allocatedWithoutNode = new HashSet<>(allocated);
            allocatedWithoutNode.remove(node);
            return new Host(hostname, initialResources, allocatedWithoutNode, possibleNodes);
        }

        Host withNode(NewNode node) {
            Set<NewNode> allocatedWithNode = new HashSet<>(allocated);
            allocatedWithNode.add(node);
            return new Host(hostname, initialResources, allocatedWithNode, satisfiedNodes);
        }

        Set<NewNode> satisfiedNodes(Set<NewNode> nodes) {
            return nodes.stream().filter(this::satisfies).collect(Collectors.toSet());
        }

        boolean satisfies(NewNode node) {
            return resources.satisfies(node.resources) && !violatesParentHostPolicy(node, this);
        }
    }

    /**
     * Class used to store the snapshots generated by a tree search, as well as some meta-data used for the search.
     */
    static class Searcher {
        List<SearchSnapshot> snapshots = new ArrayList<>();
        int deepest = 0;
        int maxNodesRemovedPerHost = 2;

        Searcher() { }
        Searcher(int maxNodesRemovedPerHost) {
            this.maxNodesRemovedPerHost = maxNodesRemovedPerHost;
        }

        /**
         * A class used to store the state of the search tree at some given point.
         */
        static class SearchSnapshot {
            MoveList moves;
            PriorityQueue<Flexiblity> flexibility;
            HashSet<Host> hosts;

            SearchSnapshot(MoveList moves, PriorityQueue<Flexiblity> flexibility, Set<Host> hosts) {
                this.moves = moves;
                this.flexibility = new PriorityQueue<>(flexibility);
                this.hosts = new HashSet<>(hosts);
            }
        }

        /**
         * A helper class to make dealing with lists of moves easier
         */
        static class MoveList {
            List<MoveOperation> moves = new ArrayList<>();

            MoveList() { }

            MoveList(List<MoveOperation> moves) {
                this.moves = moves;
            }

            MoveList with(MoveOperation moveOperation) {
                List<MoveOperation> newMoves = new ArrayList<>(moves);
                newMoves.add(moveOperation);
                return new MoveList(newMoves);
            }

            /**
             * Provides the complete path which lead the algorithm to the correct solution.
             */
            String toCompleteInstructions() {
                return moves.stream().map(MoveOperation::toString).collect(Collectors.joining("\n"));
            }

            /**
             * Returns the hostnames of the nodes that, if retired, might resolve the allocation problem.
             */
            String toSimplifiedInstructions() {
                List<MoveOperation> removals = moves.stream()
                        .filter(m -> m.removeNodes.size() > 0).collect(Collectors.toList());
                if (removals.size() == 0) {
                    return "Insertion OK";
                } else
                    return "Retire nodes:\n" +
                            removals.stream()
                                    .map(m -> m.removeNodes.stream()
                                            .map(n -> n.hostname != null ? n.hostname : n.allocation.toString())
                                            .collect(Collectors.joining("\n")))
                                    .collect(Collectors.joining("\n"));
            }

            int size() {
                return moves.size();
            }
        }

        /**
         * A class used to store information on what a move entails.
         */
        static class MoveOperation {
            Host host;
            List<NewNode> removeNodes;
            NewNode insertNode;

            MoveOperation(Host host, NewNode insertNode) {
                this.host = host;
                this.insertNode = insertNode;
                this.removeNodes = new ArrayList<>();
            }

            @Override
            public String toString() {
                if (removeNodes.size() > 0) {
                    return String.format("From %15s, remove { %s }, insert %s - %s.",
                            host.hostname,
                            removeNodes.stream().map(n -> n.resources.toString()).collect(Collectors.joining(", ")),
                            insertNode.resources,
                            insertNode.allocation);
                } else {
                    return String.format("Into %15s, insert %s - %s.",
                            host.hostname, insertNode.resources, insertNode.allocation);
                }
            }
        }

        /**
         * Search starting from a snapshot, attempting another search (with removals) from each snapshot resulting from
         * that search if it fails.
         * @return The moves leading to a solution, or `empty` if it does not exist.
         */
        Optional<MoveList> snapsearch(SearchSnapshot snapshot) {
            Searcher s = new Searcher();
            Optional<MoveList> path = s.recursiveSearch(snapshot.moves, snapshot.flexibility, snapshot.hosts);
            if (path.isPresent()) {
                return path;
            } else {
                for (SearchSnapshot snap : s.snapshots) {
                    Optional<MoveList> shufPath = searchWithRemoval(snap);
                    if (shufPath.isPresent()) return shufPath;
                }
            }
            return Optional.empty();
        }

        /**
         * Recursively generate a list of all combinations of nodes contained within the provided collection, ignoring
         * any combination which contains a node which satisfies the provided `smallerThan` node.
         * @param smallerThan Only return combinations wherein all the elements are dominated by this.
         * @param nodes The nodes from which to generate combinations.
         * @param maxDepth The maximum length of any single combination.
         * @return A list containing up to all combinations of the given nodes.
         */
        List<List<NewNode>> generateValidHostChildrenCombinations(NewNode smallerThan, Collection<NewNode> nodes, int maxDepth) {
            return generateValidHostChildrenCombinations(smallerThan, new ArrayList<>(nodes), maxDepth, 1, new HashSet<>());
        }
        List<List<NewNode>> generateValidHostChildrenCombinations(NewNode smallerThan, List<NewNode> nodes, int maxDepth, int currentDepth, HashSet<NewNode> used) {
            List<List<NewNode>> combinations = new ArrayList<>();
            if (maxDepth == 0) return combinations;
            HashSet<NewNode> newUsed = new HashSet<>(used);
            for (var node : nodes) {
                if (node.resources.satisfies(smallerThan.resources)) continue;
                if (newUsed.contains(node)) continue;
                newUsed.add(node);
                List<NewNode> nodeList = new ArrayList<>();
                nodeList.add(node);
                combinations.add(nodeList);
                if (currentDepth < maxDepth) {
                    List<NewNode> nodesWithout = new ArrayList<>(nodes);
                    nodesWithout.remove(node);
                    for (var subCombination : generateValidHostChildrenCombinations(smallerThan, nodesWithout, maxDepth, currentDepth+1, newUsed)) {
                        List<NewNode> combination = new ArrayList<>(subCombination);
                        combination.add(0, node);
                        combinations.add(combination);
                    }
                }
            }
            return combinations;
        }

        /**
         * Search that is permitted to remove nodes for a single "layer" of the search tree. Searches from the post-removal
         * snapshot will always exhaust their non-removal search trees before attempting to remove nodes for another layer.
         * @param snapshot The snapshot from where to start the search. This has to be a snapshot which has no legal moves.
         * @return The moves leading to a solution, or `empty` if it does not exist.
         */
        Optional<MoveList> searchWithRemoval(SearchSnapshot snapshot) {
            Flexiblity problem = snapshot.flexibility.poll();
            if (problem == null) throw new IllegalArgumentException("Non-problematic snapshot passed.");
            NewNode problemNode = problem.node;
            for (Host host : snapshot.hosts.stream()
                    .filter(h -> h.initialResources.satisfies(problemNode.resources))
                    .collect(Collectors.toList())) {
                for (List<NewNode> childrenToRemove : generateValidHostChildrenCombinations(problemNode, host.allocated, maxNodesRemovedPerHost)) {
                    Optional<SearchSnapshot> rehomed = rehome(snapshot, host, problemNode, childrenToRemove);
                    if (rehomed.isPresent()) return snapsearch(rehomed.get());
                }
            }
            return Optional.empty();
        }

        /**
         * Creates a new snapshot of the search tree, where the nodes `remove` have been removed from `host` and the node
         * `insert` has been inserted in their place, iff removing `remove` results in `insert` fitting in `host`.
         * @param snapshot Snapshot of the search tree which the rehoming is based on.
         * @param host Where the rehoming will happen.
         * @param insert The node to insert.
         * @param remove The node(s) to remove.
         * @return A new snapshot with updated fields and the appropriate move action in its movelist.
         */
        Optional<SearchSnapshot> rehome(SearchSnapshot snapshot, Host host, NewNode insert, List<NewNode> remove) {
            PriorityQueue<Flexiblity> flexibility = new PriorityQueue<>(snapshot.flexibility);
            flexibility.removeIf(f -> f.node == insert);
            Set<NewNode> possibleNodes = flexibility.stream().map(f -> f.node).collect(Collectors.toSet());

            Host processedHost;
            MoveOperation move = new MoveOperation(host, insert);
            if (remove.size() == 0) {
                processedHost = host;
            } else {
                possibleNodes.addAll(remove);
                Host hostWithoutRemoved = host;
                for (NewNode node : remove) hostWithoutRemoved = hostWithoutRemoved.withoutNode(node, possibleNodes);
                processedHost = hostWithoutRemoved;
                move.removeNodes = remove;
            }
            if (processedHost.satisfies(insert)) {
                Set<Host> hosts = new HashSet<>(snapshot.hosts);
                hosts.remove(host);
                hosts.add(host.withNode(insert));

                if (remove.size() != 0) {
                    flexibility.addAll(remove.stream()
                            .map(n -> new Flexiblity(n, hosts))
                            .collect(Collectors.toList()));
                }

                List<Flexiblity> outdated = flexibility.stream()
                        .filter(f -> host.satisfiedNodes.contains(f.node))
                        .collect(Collectors.toList());
                List<Flexiblity> updated = outdated.stream()
                        .map(f -> f.withPossibleHosts(hosts))
                        .collect(Collectors.toList());
                flexibility.removeAll(outdated);
                flexibility.addAll(updated);

                return Optional.of(new SearchSnapshot(snapshot.moves.with(move), flexibility, hosts));
            }
            return Optional.empty();
        }

        /**
         * @param newNodes Nodes which one wants to fit onto the hosts
         * @param hosts Hosts
         * @return Whether the given nodes can theoretically fit the remaining hosts' space.
         */
        private boolean fitFeasible(Set<NewNode> newNodes, Set<Host> hosts) {
            NodeResources totalAvailableCapacity = hosts.stream()
                    .map(h -> h.resources)
                    .reduce(new NodeResources(0, 0, 0), NodeResources::add);
            NodeResources requiredCapacity = newNodes.stream()
                    .map(n -> n.resources)
                    .reduce(new NodeResources(0, 0, 0), NodeResources::add);
            return totalAvailableCapacity.satisfies(requiredCapacity);
        }

        /**
         * Find a way to fit the given nodes onto the given hosts, using recursion.
         * @param newNodes Nodes which one wants to fit onto the hosts
         * @param hosts Hosts
         * @return An empty optional if no solution was found, the moves which result in a solution if one was found.
         */
        Optional<MoveList> search(Set<NewNode> newNodes, Set<Host> hosts) {
            if (!fitFeasible(newNodes, hosts)) {
                System.out.println("Fit impossible.");
                return Optional.empty();
            }

            PriorityQueue<Flexiblity> flexibility = new PriorityQueue<>(
                    Comparator.comparingInt(flex -> flex.possibleHosts.size()));
            flexibility.addAll(newNodes.stream().map(n -> new Flexiblity(n, hosts)).collect(Collectors.toSet()));

            PriorityQueue<Flexiblity> flexClone = new PriorityQueue<>(flexibility);
            HashSet<Host> hostsClone = new HashSet<>(hosts);

            var searchResult = recursiveSearch(flexClone, hostsClone);
            if (searchResult.isPresent()) {
                return searchResult;
            } else {
                // Retry searching from each one of the deepest points hit by the recursive search, while enabling rehoming of nodes.
                for (var snapshot : snapshots) {
                    var withRehoming = searchWithRemoval(snapshot);
                    if (withRehoming.isPresent()) return withRehoming;
                }
            }
            return Optional.empty();
        }

        /**
         * The recursing part of the search
         */
        Optional<MoveList> recursiveSearch(PriorityQueue<Flexiblity> nodes, Set<Host> hosts) {
            return recursiveSearch(new MoveList(), nodes, hosts);
        }
        Optional<MoveList> recursiveSearch(MoveList moves, PriorityQueue<Flexiblity> nodes, Set<Host> hosts) {
            if (nodes.size() == 0) {
                return Optional.of(moves);
            }
            Flexiblity leastFlexibleNode = nodes.peek();
            if (leastFlexibleNode.possibleHosts.size() == 0) { // Search branch hit dead end -- prune
                int depth = moves.size();
                if (depth >= deepest) {
                    if (depth > deepest) { // New max depth reached
                        snapshots.clear();
                        deepest = depth;
                    }
                    snapshots.add(new SearchSnapshot(moves, nodes, hosts));
                }
                return Optional.empty();
            }
            List<Host> eligibleHostsByDesirability = leastFlexibleNode.possibleHosts.stream()
                    .sorted(Comparator.comparingInt(d -> d.satisfiedNodes.size()))
                    .collect(Collectors.toList());

            for (Host host : eligibleHostsByDesirability) {
                Host updatedHost = host.withNode(leastFlexibleNode.node);
                HashSet<Host> updatedHosts = new HashSet<>(hosts);
                updatedHosts.remove(host);
                updatedHosts.add(updatedHost);

                PriorityQueue<Flexiblity> updatedNodes = new PriorityQueue<>(nodes);
                updatedNodes.poll(); // Remove the peeked node
                List<Flexiblity> outdated = updatedNodes.stream()
                        .filter(n -> host.satisfiedNodes.contains(n.node))
                        .collect(Collectors.toList());
                List<Flexiblity> updated = outdated.stream()
                        .map(n -> n.withPossibleHosts(updatedHosts))
                        .collect(Collectors.toList());
                updatedNodes.removeAll(outdated);
                updatedNodes.addAll(updated);

                MoveOperation moveOperation = new MoveOperation(host, leastFlexibleNode.node);
                Optional<MoveList> result = recursiveSearch(moves.with(moveOperation), updatedNodes, updatedHosts);
                if (result.isPresent()) {
                    return result;
                }
            }

            return Optional.empty();
        }
    }

    private static boolean violatesParentHostPolicy(NewNode node, Host host) {
        return host.allocated.stream()
                .anyMatch(allocatedNode ->
                        allocatedNode.allocation
                                .membership().cluster()
                                .equalsIgnoringGroupAndVespaVersion(node.allocation.membership().cluster())
                        && allocatedNode.allocation.owner().equals(node.allocation.owner()));
    }

    // TODO:: ^ Above should be moved to HV tool in closed source

    public CapacityChecker(NodeRepository nodeRepository) {
        this.hosts = getHosts(nodeRepository);
        List<Node> tenants = getTenants(nodeRepository, hosts);
        nodeMap = constructHostnameToNodeMap(hosts);
        this.nodeChildren = constructNodeChildrenMap(tenants, hosts, nodeMap);
        this.availableResources = constructAvailableResourcesMap(hosts, nodeChildren);
    }

    public List<Node> getHosts() {
        return hosts;
    }

    public Optional<HostFailurePath> worstCaseHostLossLeadingToFailure() {
        Map<Node, Integer> timesNodeCanBeRemoved = computeMaximalRepeatedRemovals(hosts, nodeChildren, availableResources);
        return greedyHeuristicFindFailurePath(timesNodeCanBeRemoved, hosts, nodeChildren, availableResources);
    }

    List<Node> findOvercommittedHosts() {
        return findOvercommittedNodes(availableResources);
    }

    public List<Node> nodesFromHostnames(List<String> hostnames) {
        List<Node> nodes = hostnames.stream()
                .filter(h -> nodeMap.containsKey(h))
                .map(h -> nodeMap.get(h))
                .collect(Collectors.toList());
        if (nodes.size() != hostnames.size()) {
            Set<String> notFoundNodes = new HashSet<>(hostnames);
            notFoundNodes.removeAll(nodes.stream().map(Node::hostname).collect(Collectors.toList()));
            throw new IllegalArgumentException(String.format("Host(s) not found: [ %s ]",
                    String.join(", ", notFoundNodes)));
        }

        return nodes;
    }

    public Optional<HostFailurePath> findHostRemovalFailure(List<Node> hostsToRemove) {
        Optional<HostRemovalFailure> removal = findHostRemovalFailure(hostsToRemove, hosts, nodeChildren, availableResources);
        if (removal.isEmpty()) return Optional.empty();
        HostFailurePath failurePath = new HostFailurePath();
        failurePath.hostsCausingFailure = hostsToRemove;
        failurePath.failureReason = removal.get();
        return Optional.of(failurePath);
    }

    // We only care about nodes in one of these states.
    private static Node.State[] relevantNodeStates = {
            Node.State.active,
            Node.State.inactive,
            Node.State.dirty,
            Node.State.provisioned,
            Node.State.ready,
            Node.State.reserved
    };

    private List<Node> getHosts(NodeRepository nodeRepository) {
        return nodeRepository.getNodes(NodeType.host, relevantNodeStates);
    }

    private List<Node> getTenants(NodeRepository nodeRepository, List<Node> hosts) {
        Set<String> parentNames = hosts.stream().map(Node::hostname).collect(Collectors.toSet());
        return nodeRepository.getNodes(NodeType.tenant, relevantNodeStates).stream()
                .filter(t -> parentNames.contains(t.parentHostname().orElse("")))
                .collect(Collectors.toList());
    }

    private Optional<HostFailurePath> greedyHeuristicFindFailurePath(Map<Node, Integer> heuristic, List<Node> hosts,
                                                                     Map<Node, List<Node>> nodeChildren,
                                                                     Map<Node, AllocationResources> availableResources) {
        if (hosts.size() == 0) return Optional.empty();

        List<Node> parentRemovalPriorityList = heuristic.entrySet().stream()
                .sorted(Comparator.comparingInt(Map.Entry::getValue))
                .map(Map.Entry::getKey)
                .collect(Collectors.toList());

        for (int i = 1; i <= parentRemovalPriorityList.size(); i++) {
            List<Node> hostsToRemove = parentRemovalPriorityList.subList(0, i);
            Optional<HostRemovalFailure> hostRemovalFailure = findHostRemovalFailure(hostsToRemove, hosts, nodeChildren, availableResources);
            if (hostRemovalFailure.isPresent()) {
                HostFailurePath failurePath = new HostFailurePath();
                failurePath.hostsCausingFailure = hostsToRemove;
                failurePath.failureReason = hostRemovalFailure.get();
                return Optional.of(failurePath);
            }
        }

        throw new IllegalStateException("No path to failure found. This should be impossible!");
    }

    private Map<String, Node> constructHostnameToNodeMap(List<Node> nodes) {
        return nodes.stream().collect(Collectors.toMap(Node::hostname, n -> n));
    }

    private Map<Node, List<Node>> constructNodeChildrenMap(List<Node> tenants, List<Node> hosts, Map<String, Node> hostnameToNode) {
        Map<Node, List<Node>> nodeChildren = tenants.stream()
                .filter(n -> n.parentHostname().isPresent())
                .filter(n -> hostnameToNode.containsKey(n.parentHostname().get()))
                .collect(Collectors.groupingBy(
                        n -> hostnameToNode.get(n.parentHostname().orElseThrow())));

        hosts.forEach(host -> nodeChildren.putIfAbsent(host, List.of()));

        return nodeChildren;
    }

    private Map<Node, AllocationResources> constructAvailableResourcesMap(List<Node> hosts, Map<Node, List<Node>> nodeChildren) {
        Map<Node, AllocationResources> availableResources = new HashMap<>();
        for (Node host : hosts) {
            NodeResources hostResources = host.flavor().resources();
            int occupiedIps = 0;
            Set<String> ipPool = host.ipAddressPool().asSet();
            for (Node child : nodeChildren.get(host)) {
                hostResources = hostResources.subtract(child.flavor().resources().withDiskSpeed(NodeResources.DiskSpeed.any));
                occupiedIps += child.ipAddresses().stream().filter(ipPool::contains).count();
            }
            availableResources.put(host, new AllocationResources(hostResources, host.ipAddressPool().asSet().size() - occupiedIps));
        }

        return availableResources;
    }

    /**
     * Computes a heuristic for each host, with a lower score indicating a higher perceived likelihood that removing
     * the host causes an unrecoverable state
     */
    private Map<Node, Integer> computeMaximalRepeatedRemovals(List<Node> hosts, Map<Node, List<Node>> nodeChildren,
                                                              Map<Node, AllocationResources> availableResources) {
        Map<Node, Integer> timesNodeCanBeRemoved = hosts.stream().collect(Collectors.toMap(
                Function.identity(),
                _x -> Integer.MAX_VALUE
        ));
        for (Node host : hosts) {
            List<Node> children = nodeChildren.get(host);
            if (children.size() == 0) continue;
            Map<Node, AllocationResources> resourceMap = new HashMap<>(availableResources);
            Map<Node, List<Allocation>> containedAllocations = collateAllocations(nodeChildren);

            int timesHostCanBeRemoved = 0;
            Optional<Node> unallocatedNode;
            while (timesHostCanBeRemoved < 1000) { // Arbritrary upper bound
                unallocatedNode = tryAllocateNodes(nodeChildren.get(host), hosts, resourceMap, containedAllocations);
                if (unallocatedNode.isEmpty()) {
                    timesHostCanBeRemoved++;
                } else break;
            }
            timesNodeCanBeRemoved.put(host, timesHostCanBeRemoved);
        }

        return timesNodeCanBeRemoved;
    }

    private List<Node> findOvercommittedNodes(Map<Node, AllocationResources> availableResources) {
        List<Node> overcommittedNodes = new ArrayList<>();
        for (var entry : availableResources.entrySet()) {
            NodeResources resources = entry.getValue().nodeResources;
            if (resources.vcpu() < 0 || resources.memoryGb() < 0 || resources.diskGb() < 0) {
                overcommittedNodes.add(entry.getKey());
            }
        }
        return overcommittedNodes;
    }

    private Map<Node, List<Allocation>> collateAllocations(Map<Node, List<Node>> nodeChildren) {
        return nodeChildren.entrySet().stream().collect(Collectors.toMap(
                Map.Entry::getKey,
                e -> e.getValue().stream()
                        .map(Node::allocation).flatMap(Optional::stream)
                        .collect(Collectors.toList())
        ));
    }

    /**
     * Tests whether it's possible to remove the provided hosts.
     * Does not mutate any input variable.
     * @return Empty optional if removal is possible, information on what caused the failure otherwise
     */
    private Optional<HostRemovalFailure> findHostRemovalFailure(List<Node> hostsToRemove, List<Node> allHosts,
                                                                Map<Node, List<Node>> nodechildren,
                                                                Map<Node, AllocationResources> availableResources) {
        Map<Node, List<Allocation>> containedAllocations = collateAllocations(nodechildren);
        HashMap<Node, AllocationResources> resourceMap = new HashMap<>(availableResources);
        List<Node> validAllocationTargets = allHosts.stream()
                .filter(h -> !hostsToRemove.contains(h))
                .collect(Collectors.toList());
        if (validAllocationTargets.size() == 0) {
            return Optional.of(HostRemovalFailure.none());
        }

        allocationHistory = new AllocationHistory();
        for (Node host : hostsToRemove) {
            Optional<Node> unallocatedNode = tryAllocateNodes(nodechildren.get(host),
                    validAllocationTargets, resourceMap, containedAllocations, true);

            if (unallocatedNode.isPresent()) {
                AllocationFailureReasonList failures = collateAllocationFailures(unallocatedNode.get(),
                        validAllocationTargets, resourceMap, containedAllocations);
                return Optional.of(HostRemovalFailure.create(host, unallocatedNode.get(), failures));
            }
        }
        return Optional.empty();
    }

    /**
     * Attempts to allocate the listed nodes to a new host, mutating availableResources and containedAllocations,
     * optionally returning the first node to fail, if one does.
     * */
    private Optional<Node> tryAllocateNodes(List<Node> nodes, List<Node> hosts,
                                            Map<Node, AllocationResources> availableResources,
                                            Map<Node, List<Allocation>> containedAllocations) {
        return tryAllocateNodes(nodes, hosts, availableResources, containedAllocations, false);
    }
    private Optional<Node> tryAllocateNodes(List<Node> nodes, List<Node> hosts,
                                            Map<Node, AllocationResources> availableResources,
                                            Map<Node, List<Allocation>> containedAllocations, boolean withHistory) {
        for (Node node : nodes) {
            Optional<Node> newParent = tryAllocateNode(node, hosts, availableResources, containedAllocations);
            if (newParent.isEmpty()) {
                if (withHistory) allocationHistory.addEntry(node, null, 0);
                return Optional.of(node);
            }
            if (withHistory) {
                long eligibleParents =
                    hosts.stream().filter(h ->
                            !violatesParentHostPolicy(node, h, containedAllocations)
                                && availableResources.get(h).satisfies(AllocationResources.from(node.flavor().resources()))).count();
                allocationHistory.addEntry(node, newParent.get(), eligibleParents + 1);
            }
        }
        return Optional.empty();
    }

    /**
     * @return The parent to which the node was allocated, if it was successfully allocated.
     */
    private Optional<Node> tryAllocateNode(Node node, List<Node> hosts,
                                    Map<Node, AllocationResources> availableResources,
                                    Map<Node, List<Allocation>> containedAllocations) {
        AllocationResources requiredNodeResources = AllocationResources.from(node.flavor().resources());
        for (Node host : hosts) {
            AllocationResources availableHostResources = availableResources.get(host);
            if (violatesParentHostPolicy(node, host, containedAllocations)) {
                continue;
            }
            if (availableHostResources.satisfies(requiredNodeResources)) {
                availableResources.put(host, availableHostResources.subtract(requiredNodeResources));
                if (node.allocation().isPresent()) {
                    containedAllocations.get(host).add(node.allocation().get());
                }
                return Optional.of(host);
            }
        }

        return Optional.empty();
    }

    private static boolean violatesParentHostPolicy(Node node, Node host, Map<Node, List<Allocation>> containedAllocations) {
        if (node.allocation().isEmpty()) return false;
        Allocation nodeAllocation = node.allocation().get();
        return containedAllocations.get(host).stream()
                .anyMatch(allocation ->
                        allocation.membership().cluster()
                                .equalsIgnoringGroupAndVespaVersion(nodeAllocation.membership().cluster())
                        && allocation.owner().equals(nodeAllocation.owner()));
    }

    private AllocationFailureReasonList collateAllocationFailures(Node node, List<Node> hosts,
                                                                  Map<Node, AllocationResources> availableResources,
                                                                  Map<Node, List<Allocation>> containedAllocations) {
        List<AllocationFailureReason> allocationFailureReasons = new ArrayList<>();
        for (Node host : hosts) {
            AllocationFailureReason reason = new AllocationFailureReason(host);
            AllocationResources availableHostResources = availableResources.get(host);
            reason.violatesParentHostPolicy = violatesParentHostPolicy(node, host, containedAllocations);

            NodeResources l = availableHostResources.nodeResources;
            NodeResources r = node.flavor().resources();
            if (l.vcpu()      < r.vcpu())                   { reason.insufficientVcpu = true;         }
            if (l.memoryGb()  < r.memoryGb())               { reason.insufficientMemoryGb = true;     }
            if (l.diskGb()    < r.diskGb())                 { reason.insufficientDiskGb = true;       }
            if (r.diskSpeed() != NodeResources.DiskSpeed.any && r.diskSpeed() != l.diskSpeed())
            { reason.incompatibleDiskSpeed = true;    }
            if (availableHostResources.availableIPs < 1)    { reason.insufficientAvailableIPs = true; }

            allocationFailureReasons.add(reason);
        }

        return new AllocationFailureReasonList(allocationFailureReasons);
    }

    /**
     * Contains the list of hosts that, upon being removed, caused an unrecoverable state,
     * as well as the specific host and tenant which caused it.
     */
    public static class HostFailurePath {
        public List<Node> hostsCausingFailure;
        public HostRemovalFailure failureReason;
    }

    /**
     * Data class used for detailing why removing the given tenant from the given host was unsuccessful.
     * A failure might not be caused by failing to allocate a specific tenant, in which case the fields
     * will be empty.
     */
    public static class HostRemovalFailure {
        public Optional<Node> host;
        public Optional<Node> tenant;
        public AllocationFailureReasonList allocationFailures;

        public static HostRemovalFailure none() {
            return new HostRemovalFailure(
                    Optional.empty(),
                    Optional.empty(),
                    new AllocationFailureReasonList(List.of()));
        }

        public static HostRemovalFailure create(Node host, Node tenant, AllocationFailureReasonList failureReasons) {
            return new HostRemovalFailure(
                    Optional.of(host),
                    Optional.of(tenant),
                    failureReasons);
        }

        private HostRemovalFailure(Optional<Node> host, Optional<Node> tenant, AllocationFailureReasonList allocationFailures) {
            this.host = host;
            this.tenant = tenant;
            this.allocationFailures = allocationFailures;
        }

        @Override
        public String toString() {
            if (host.isEmpty() || tenant.isEmpty()) return "No removal candidates exists.";
            return String.format(
                    "Failure to remove host %s" +
                    "\n\tNo new host found for tenant %s:" +
                    "\n\t\tSingular Reasons: %s" +
                    "\n\t\tTotal Reasons:    %s",
                    this.host.get().hostname(),
                    this.tenant.get().hostname(),
                    this.allocationFailures.singularReasonFailures().toString(),
                    this.allocationFailures.toString()
            );
        }
    }

    /**
     * Used to describe the resources required for a tenant, and available to a host.
     */
    private static class AllocationResources {
        NodeResources nodeResources;
        int availableIPs;

        public static AllocationResources from(NodeResources nodeResources) {
            return new AllocationResources(nodeResources, 1);
        }

        AllocationResources(NodeResources nodeResources, int availableIPs) {
            this.nodeResources = nodeResources;
            this.availableIPs = availableIPs;
        }

        boolean satisfies(AllocationResources other) {
            if (!this.nodeResources.satisfies(other.nodeResources)) return false;
            return this.availableIPs >= other.availableIPs;
        }

        AllocationResources subtract(AllocationResources other) {
            return new AllocationResources(this.nodeResources.subtract(other.nodeResources), this.availableIPs - other.availableIPs);
        }
    }

    /**
     * Keeps track of the reason why a host rejected an allocation.
     */
    private static class AllocationFailureReason {
        Node host;
        AllocationFailureReason (Node host) {
            this.host = host;
        }
        boolean insufficientVcpu = false;
        boolean insufficientMemoryGb = false;
        boolean insufficientDiskGb = false;
        boolean incompatibleDiskSpeed = false;
        boolean insufficientAvailableIPs = false;
        boolean violatesParentHostPolicy = false;

        int numberOfReasons() {
            int n = 0;
            if (insufficientVcpu) n++;
            if (insufficientMemoryGb) n++;
            if (insufficientDiskGb) n++;
            if (incompatibleDiskSpeed) n++;
            if (insufficientAvailableIPs) n++;
            if (violatesParentHostPolicy) n++;
            return n;
        }

        @Override
        public String toString() {
            List<String> reasons = new ArrayList<>();
            if (insufficientVcpu) reasons.add("insufficientVcpu");
            if (insufficientMemoryGb) reasons.add("insufficientMemoryGb");
            if (insufficientDiskGb) reasons.add("insufficientDiskGb");
            if (incompatibleDiskSpeed) reasons.add("incompatibleDiskSpeed");
            if (insufficientAvailableIPs) reasons.add("insufficientAvailableIPs");
            if (violatesParentHostPolicy) reasons.add("violatesParentHostPolicy");

            return String.format("[%s]", String.join(", ", reasons));
        }
    }

    /**
     * Provides convenient methods for tallying failures.
     */
    public static class AllocationFailureReasonList {
        private List<AllocationFailureReason> allocationFailureReasons;
        AllocationFailureReasonList(List<AllocationFailureReason> allocationFailureReasons) {
            this.allocationFailureReasons = allocationFailureReasons;
        }

        public long insufficientVcpu()         { return allocationFailureReasons.stream().filter(r -> r.insufficientVcpu).count(); }
        public long insufficientMemoryGb()     { return allocationFailureReasons.stream().filter(r -> r.insufficientMemoryGb).count(); }
        public long insufficientDiskGb()       { return allocationFailureReasons.stream().filter(r -> r.insufficientDiskGb).count(); }
        public long incompatibleDiskSpeed()    { return allocationFailureReasons.stream().filter(r -> r.incompatibleDiskSpeed).count(); }
        public long insufficientAvailableIps() { return allocationFailureReasons.stream().filter(r -> r.insufficientAvailableIPs).count(); }
        public long violatesParentHostPolicy() { return allocationFailureReasons.stream().filter(r -> r.violatesParentHostPolicy).count(); }

        public AllocationFailureReasonList singularReasonFailures() {
            return new AllocationFailureReasonList(allocationFailureReasons.stream()
                    .filter(reason -> reason.numberOfReasons() == 1).collect(Collectors.toList()));
        }
        AllocationFailureReasonList multipleReasonFailures() {
            return new AllocationFailureReasonList(allocationFailureReasons.stream()
                    .filter(reason -> reason.numberOfReasons() > 1).collect(Collectors.toList()));
        }
        public long size() {
            return allocationFailureReasons.size();
        }
        @Override
        public String toString() {
            return String.format("CPU (%3d), Memory (%3d), Disk size (%3d), Disk speed (%3d), IP (%3d), Parent-Host Policy (%3d)",
                    insufficientVcpu(), insufficientMemoryGb(), insufficientDiskGb(),
                    incompatibleDiskSpeed(), insufficientAvailableIps(), violatesParentHostPolicy());
        }
    }

    public static class AllocationHistory {
        public static class Entry {
            public Node tenant;
            public Node newParent;
            public long eligibleParents;

            public Entry(Node tenant, Node newParent, long eligibleParents) {
                this.tenant = tenant;
                this.newParent = newParent;
                this.eligibleParents = eligibleParents;
            }

            @Override
            public String toString() {
                return String.format("%-20s %-65s -> %15s [%3d valid]",
                        tenant.hostname().replaceFirst("\\..+", ""),
                        tenant.flavor().resources(),
                        newParent == null ? "x" : newParent.hostname().replaceFirst("\\..+", ""),
                        this.eligibleParents
                );
            }
        }

        public List<Entry> historyEntries;

        AllocationHistory() {
            this.historyEntries = new ArrayList<>();
        }

        void addEntry(Node tenant, Node newParent, long eligibleParents) {
            this.historyEntries.add(new Entry(tenant, newParent, eligibleParents));
        }

        public Set<String> oldParents() {
            Set<String> oldParents = new HashSet<>();
            historyEntries.forEach(entry -> entry.tenant.parentHostname().ifPresent(oldParents::add));
            return oldParents;
        }

        @Override
        public String toString() {
            StringBuilder out = new StringBuilder();

            String currentParent = "";
            for (Entry entry : historyEntries) {
                String parentName = entry.tenant.parentHostname().orElseThrow();
                if (!parentName.equals(currentParent)) {
                    currentParent = parentName;
                    out.append(parentName).append("\n");
                }
                out.append(entry.toString()).append("\n");
            }

            return out.toString();
        }
    }
}
